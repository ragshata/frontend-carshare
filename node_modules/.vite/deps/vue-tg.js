import {
  computed,
  createBlock,
  defineComponent,
  onMounted,
  onUnmounted,
  openBlock,
  readonly,
  ref,
  resolveDynamicComponent,
  watch,
  withCtx
} from "./chunk-VT7FWPCL.js";
import "./chunk-SSYGV25P.js";

// node_modules/vue-tg/dist/index.es.js
var We = defineComponent({
  __name: "Alert",
  props: {
    message: {
      type: String,
      required: true
    }
  },
  emits: ["close"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showAlert: a } = k();
    return onMounted(() => a(t.message, () => n("close"))), (i, s) => null;
  }
});
var Se = defineComponent({
  __name: "BackButton",
  props: {
    visible: { type: Boolean, default: true }
  },
  emits: ["click"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showBackButton: a, onBackButtonClicked: i, hideBackButton: s } = Ne();
    return watch(
      () => t.visible,
      (l) => {
        l ? a() : s();
      }
    ), i(() => n("click")), onMounted(() => t.visible && a()), onUnmounted(() => s()), (l, f) => null;
  }
});
var Ce = defineComponent({
  __name: "BiometricManager",
  emits: ["init"],
  setup(e, { emit: o }) {
    const t = o, { initBiometric: n } = Ze();
    return onMounted(() => n(() => t("init"))), (a, i) => null;
  }
});
var ye = defineComponent({
  __name: "ClosingConfirmation",
  setup(e) {
    const { enableClosingConfirmation: o, disableClosingConfirmation: t } = tt();
    return onMounted(() => o()), onUnmounted(() => t()), (n, a) => null;
  }
});
var ke = defineComponent({
  __name: "Confirm",
  props: {
    message: { type: String, required: true }
  },
  emits: ["close"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showConfirm: a } = k();
    return onMounted(() => a(t.message, (i) => n("close", i))), (i, s) => null;
  }
});
var we = defineComponent({
  __name: "ExpandedViewport",
  props: {
    force: { type: Boolean, default: false }
  },
  setup(e) {
    const o = e, { isFeatureSupported: t } = g(), { onViewportChanged: n, expand: a, isExpanded: i, isVerticalSwipesEnabled: s } = _t();
    return t("DisableVerticalSwipes") ? watch(
      () => o.force,
      (l) => {
        l && !i.value && a(), s.value = !l;
      },
      {
        immediate: true
      }
    ) : n(({ isStateStable: l }) => {
      o.force && l && !i.value && a();
    }), onMounted(() => a()), (l, f) => null;
  }
});
var Me = defineComponent({
  __name: "MainButton",
  props: {
    text: { type: String },
    color: { type: String },
    textColor: { type: String },
    visible: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    progress: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(e, { emit: o }) {
    const t = e, n = o, {
      setMainButtonParams: a,
      onMainButtonClicked: i,
      hideMainButton: s,
      showMainButtonProgress: l,
      hideMainButtonProgress: f
    } = pt();
    return watch(
      () => t.text,
      (c) => {
        a({
          text: c
        });
      }
    ), watch(
      () => t.color,
      (c) => {
        a({
          color: c
        });
      }
    ), watch(
      () => t.textColor,
      (c) => {
        a({
          text_color: c
        });
      }
    ), watch(
      () => t.visible,
      (c) => {
        a({
          is_visible: c
        });
      }
    ), watch(
      () => t.disabled,
      (c) => {
        a({
          is_active: !c
        });
      }
    ), watch(
      () => t.progress,
      (c) => {
        c ? l() : f();
      }
    ), i(() => n("click")), onMounted(() => {
      t.progress ? l() : f(), a({
        text: t.text,
        text_color: t.textColor,
        color: t.color,
        is_active: !t.disabled,
        is_visible: t.visible
      });
    }), onUnmounted(() => {
      f(), s();
    }), (c, Et) => null;
  }
});
var xe = defineComponent({
  __name: "Popup",
  props: {
    title: { type: String },
    message: { type: String, required: true },
    buttons: { type: Array }
  },
  emits: ["close"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showPopup: a } = k();
    return onMounted(
      () => a(
        {
          title: t.title,
          message: t.message,
          buttons: t.buttons
        },
        (i) => n("close", i)
      )
    ), (i, s) => null;
  }
});
var Pe = defineComponent({
  __name: "ScanQr",
  props: {
    text: { type: String }
  },
  emits: ["result"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showScanQrPopup: a, closeScanQrPopup: i } = vt();
    return onMounted(
      () => a(
        {
          text: t.text
        },
        (s) => n("result", s)
      )
    ), onUnmounted(() => i()), (s, l) => null;
  }
});
var _e = defineComponent({
  __name: "SettingsButton",
  props: {
    visible: { type: Boolean, default: true }
  },
  emits: ["click"],
  setup(e, { emit: o }) {
    const t = e, n = o, { showSettingsButton: a, onSettingsButtonClicked: i, hideSettingsButton: s } = Mt();
    return watch(
      () => t.visible,
      (l) => {
        l ? a() : s();
      }
    ), i(() => n("click")), onMounted(() => t.visible && a()), onUnmounted(() => s()), (l, f) => null;
  }
});
var Ee = defineComponent({
  __name: "ShareWidget",
  props: {
    url: {
      type: String,
      required: true
    },
    comment: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    noLabel: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const o = e, t = computed(() => JSON.stringify(o));
    return (n, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { key: t.value }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-share-url": e.url,
          "data-size": e.size,
          "data-comment": e.comment,
          "data-text": e.noLabel ? "notext" : null
        }, null, 8, ["data-telegram-share-url", "data-size", "data-comment", "data-text"]))
      ]),
      _: 1
    }));
  }
});
var qe = defineComponent({
  __name: "PostWidget",
  props: {
    url: {
      type: String,
      required: true
    },
    width: {
      type: String,
      default: null
    },
    authorPhoto: {
      type: Boolean,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    darkColor: {
      type: String,
      default: null
    },
    dark: {
      type: Boolean,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const o = e, t = computed(() => JSON.stringify(o));
    return (n, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { key: t.value }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-post": e.url,
          "data-width": e.width,
          "data-userpic": e.authorPhoto,
          "data-color": e.color,
          "data-dark-color": e.darkColor,
          "data-dark": e.dark
        }, null, 8, ["data-telegram-post", "data-width", "data-userpic", "data-color", "data-dark-color", "data-dark"]))
      ]),
      _: 1
    }));
  }
});
var Re = defineComponent({
  __name: "LoginWidget",
  props: {
    botUsername: {
      type: String,
      required: true
    },
    redirectUrl: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    cornerRadius: {
      type: String,
      default: null
    },
    userPhoto: {
      type: Boolean,
      default: null
    },
    requestWrite: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: ["auth"],
  setup(e, { emit: o }) {
    const t = e, n = computed(() => JSON.stringify(t)), a = o;
    return onMounted(() => {
      window.onTelegramAuth = (i) => a("auth", i);
    }), (i, s) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { key: n.value }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-login": e.botUsername,
          "data-size": e.size,
          "data-radius": e.cornerRadius,
          "data-userpic": e.userPhoto,
          "data-request-access": e.requestWrite ? "write" : null,
          "data-onauth": e.redirectUrl ? null : "onTelegramAuth(user)",
          "data-auth-url": e.redirectUrl
        }, null, 8, ["data-telegram-login", "data-size", "data-radius", "data-userpic", "data-request-access", "data-onauth", "data-auth-url"]))
      ]),
      _: 1
    }));
  }
});
var De = defineComponent({
  __name: "DiscussionWidget",
  props: {
    url: {
      type: String,
      required: true
    },
    commentsLimit: {
      type: Number,
      default: null
    },
    height: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    darkColor: {
      type: String,
      default: null
    },
    dark: {
      type: Boolean,
      default: null
    },
    colorful: {
      type: Boolean,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const o = e, t = computed(() => JSON.stringify(o));
    return (n, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { key: t.value }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent("script"), {
          async: "",
          src: "https://telegram.org/js/telegram-widget.js?22",
          "data-telegram-discussion": e.url,
          "data-comments-limit": e.commentsLimit,
          "data-height": e.height,
          "data-color": e.color,
          "data-dark-color": e.darkColor,
          "data-dark": e.dark,
          "data-colorful": e.colorful
        }, null, 8, ["data-telegram-discussion", "data-comments-limit", "data-height", "data-color", "data-dark-color", "data-dark", "data-colorful"]))
      ]),
      _: 1
    }));
  }
});
var {
  initData: $e,
  initDataUnsafe: Ve,
  version: Ie,
  platform: Ue,
  isVersionAtLeast: j,
  sendData: Qe,
  close: He
} = Telegram.WebApp;
var N = ref(false);
var Le = (...e) => {
  Telegram.WebApp.ready(...e), N.value = true;
};
var J = (e) => Telegram.WebApp.platform === e;
var G = J("unknown");
var ze = {
  ClosingConfirmation: "6.2",
  CloudStorage: "6.9",
  RequestWriteAccess: "6.9",
  RequestContact: "6.9",
  SettingsButton: "7.0",
  BiometricManager: "7.2",
  DisableVerticalSwipes: "7.7"
};
var Oe = (e) => j(ze[e]);
var je = !G && Telegram.WebApp.initData === "";
function g() {
  return {
    initData: $e,
    initDataUnsafe: Ve,
    version: Ie,
    platform: Ue,
    isVersionAtLeast: j,
    onEvent: (o, t, n = { manual: false }) => {
      const { manual: a } = n, i = () => {
        Telegram.WebApp.onEvent(
          o,
          t
        );
      }, s = () => {
        Telegram.WebApp.offEvent(
          o,
          t
        );
      };
      return a ? i() : (onMounted(i), onUnmounted(s)), {
        off: s
      };
    },
    sendData: Qe,
    ready: Le,
    close: He,
    isReady: readonly(N),
    isPlatform: J,
    isPlatformUnknown: G,
    isFeatureSupported: Oe,
    canSendData: je
  };
}
var F = ref(Telegram.WebApp.BackButton.isVisible);
function K() {
  F.value = Telegram.WebApp.BackButton.isVisible;
}
function M(...e) {
  Telegram.WebApp.BackButton.show(...e), K();
}
function x(...e) {
  Telegram.WebApp.BackButton.hide(...e), K();
}
function Ne() {
  const { onEvent: e } = g(), o = (t, n) => e("backButtonClicked", t, n);
  return {
    isBackButtonVisible: computed({
      get() {
        return F.value;
      },
      set(t) {
        t ? M() : x();
      }
    }),
    onBackButtonClicked: o,
    showBackButton: M,
    hideBackButton: x
  };
}
var {
  init: Je,
  requestAccess: Ge,
  authenticate: Fe,
  updateBiometricToken: Ke,
  openSettings: Xe
} = Telegram.WebApp.BiometricManager;
var X = ref(Telegram.WebApp.BiometricManager.isInited);
var Y = ref(
  Telegram.WebApp.BiometricManager.isBiometricAvailable
);
var Z = ref(Telegram.WebApp.BiometricManager.biometricType);
var ee = ref(
  Telegram.WebApp.BiometricManager.isAccessRequested
);
var te = ref(
  Telegram.WebApp.BiometricManager.isAccessGranted
);
var ne = ref(
  Telegram.WebApp.BiometricManager.isAccessGranted
);
var oe = ref(Telegram.WebApp.BiometricManager.deviceId);
function Ye() {
  X.value = Telegram.WebApp.BiometricManager.isInited, Y.value = Telegram.WebApp.BiometricManager.isBiometricAvailable, Z.value = Telegram.WebApp.BiometricManager.biometricType, ee.value = Telegram.WebApp.BiometricManager.isAccessRequested, te.value = Telegram.WebApp.BiometricManager.isAccessGranted, oe.value = Telegram.WebApp.BiometricManager.deviceId, ne.value = Telegram.WebApp.BiometricManager.isBiometricTokenSaved;
}
function Ze() {
  const { onEvent: e } = g(), o = (a, i) => e("biometricManagerUpdated", a, i), t = (a, i) => e("biometricAuthRequested", a, i), n = (a, i) => e("biometricTokenUpdated", a, i);
  return o(Ye), {
    isBiometricInited: readonly(X),
    isBiometricAvailable: readonly(Y),
    biometricType: readonly(Z),
    isBiometricAccessRequested: readonly(ee),
    isBiometricAccessGranted: readonly(te),
    isBiometricTokenSaved: readonly(ne),
    biometricDeviceId: readonly(oe),
    initBiometric: Je,
    requestBiometricAccess: Ge,
    authenticateBiometric: Fe,
    updateBiometricToken: Ke,
    openBiometricSettings: Xe,
    onBiometricManagerUpdated: o,
    onBiometricAuthRequested: t,
    onBiometricTokenUpdated: n
  };
}
var { readTextFromClipboard: et } = Telegram.WebApp;
function Rt() {
  const { onEvent: e } = g();
  return {
    readTextFromClipboard: et,
    onClipboardTextReceived: (t, n) => e("clipboardTextReceived", t, n)
  };
}
var ae = ref(
  Telegram.WebApp.isClosingConfirmationEnabled
);
function ie() {
  ae.value = Telegram.WebApp.isClosingConfirmationEnabled;
}
function P(...e) {
  Telegram.WebApp.enableClosingConfirmation(...e), ie();
}
function _(...e) {
  Telegram.WebApp.disableClosingConfirmation(...e), ie();
}
function tt() {
  return {
    isClosingConfirmationEnabled: computed({
      get() {
        return ae.value;
      },
      set(e) {
        e ? P() : _();
      }
    }),
    enableClosingConfirmation: P,
    disableClosingConfirmation: _
  };
}
var W = Telegram.WebApp.CloudStorage;
function nt(e, o) {
  return new Promise((t, n) => {
    W.setItem(e, o, (a, i) => {
      a && n(a), t(i);
    });
  });
}
function ot(e) {
  return new Promise((o, t) => {
    W.getItem(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function at(e) {
  return new Promise((o, t) => {
    W.getItems(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function it(e) {
  return new Promise((o, t) => {
    W.removeItem(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function rt(e) {
  return new Promise((o, t) => {
    W.removeItems(e, (n, a) => {
      n && t(n), o(a);
    });
  });
}
function st() {
  return new Promise((e, o) => {
    W.getKeys((t, n) => {
      t && o(t), e(n);
    });
  });
}
function Dt() {
  return {
    setStorageItem: nt,
    getStorageItem: ot,
    getStorageItems: at,
    removeStorageItem: it,
    removeStorageItems: rt,
    getStorageKeys: st
  };
}
var { impactOccurred: ct, notificationOccurred: lt, selectionChanged: ut } = Telegram.WebApp.HapticFeedback;
function $t() {
  return {
    impactOccurred: ct,
    notificationOccurred: lt,
    selectionChanged: ut
  };
}
var re = ref(Telegram.WebApp.MainButton.text);
var se = ref(Telegram.WebApp.MainButton.color);
var ce = ref(Telegram.WebApp.MainButton.textColor);
var le = ref(Telegram.WebApp.MainButton.isVisible);
var ue = ref(Telegram.WebApp.MainButton.isActive);
var pe = ref(
  Telegram.WebApp.MainButton.isProgressVisible
);
function h() {
  re.value = Telegram.WebApp.MainButton.text, se.value = Telegram.WebApp.MainButton.color, ce.value = Telegram.WebApp.MainButton.textColor, le.value = Telegram.WebApp.MainButton.isVisible, ue.value = Telegram.WebApp.MainButton.isActive, pe.value = Telegram.WebApp.MainButton.isProgressVisible;
}
function E(...e) {
  Telegram.WebApp.MainButton.setText(...e), h();
}
function q(...e) {
  Telegram.WebApp.MainButton.show(...e), h();
}
function R(...e) {
  Telegram.WebApp.MainButton.hide(...e), h();
}
function D(...e) {
  Telegram.WebApp.MainButton.enable(...e), h();
}
function $(...e) {
  Telegram.WebApp.MainButton.disable(...e), h();
}
function V(...e) {
  Telegram.WebApp.MainButton.showProgress(...e), h();
}
function I(...e) {
  Telegram.WebApp.MainButton.hideProgress(...e), h();
}
function y(...e) {
  Telegram.WebApp.MainButton.setParams(...e), h();
}
function pt() {
  const { onEvent: e } = g(), o = (t, n) => e("mainButtonClicked", t, n);
  return {
    mainButtonText: computed({
      get() {
        return re.value;
      },
      set(t) {
        E(t);
      }
    }),
    mainButtonColor: computed({
      get() {
        return se.value;
      },
      set(t) {
        y({
          color: t
        });
      }
    }),
    mainButtonTextColor: computed({
      get() {
        return ce.value;
      },
      set(t) {
        y({
          text_color: t
        });
      }
    }),
    isMainButtonVisible: computed({
      get() {
        return le.value;
      },
      set(t) {
        t ? q() : R();
      }
    }),
    isMainButtonActive: computed({
      get() {
        return ue.value;
      },
      set(t) {
        t ? D() : $();
      }
    }),
    isMainButtonProgressVisible: computed({
      get() {
        return pe.value;
      },
      set(t) {
        t ? V() : I();
      }
    }),
    setMainButtonText: E,
    onMainButtonClicked: o,
    showMainButton: q,
    hideMainButton: R,
    enableMainButton: D,
    disableMainButton: $,
    showMainButtonProgress: V,
    hideMainButtonProgress: I,
    setMainButtonParams: y
  };
}
var { switchInlineQuery: mt, openLink: gt, openTelegramLink: dt, openInvoice: bt } = Telegram.WebApp;
function Vt() {
  const { onEvent: e } = g();
  return {
    switchInlineQuery: mt,
    openLink: gt,
    openTelegramLink: dt,
    openInvoice: bt,
    onInvoiceClosed: (t, n) => e("invoiceClosed", t, n)
  };
}
var { showPopup: ft, showAlert: Bt, showConfirm: At } = Telegram.WebApp;
function k() {
  const { onEvent: e } = g();
  return {
    showPopup: ft,
    showAlert: Bt,
    showConfirm: At,
    onPopupClosed: (t, n) => e("popupClosed", t, n)
  };
}
var { showScanQrPopup: Tt, closeScanQrPopup: ht } = Telegram.WebApp;
function vt() {
  const { onEvent: e } = g();
  return {
    showScanQrPopup: Tt,
    closeScanQrPopup: ht,
    onQrTextReceived: (n, a) => e("qrTextReceived", n, a),
    onScanQrPopupClosed: (n, a) => e("scanQrPopupClosed", n, a)
  };
}
var { requestContact: Wt, requestWriteAccess: St } = Telegram.WebApp;
function It() {
  const { onEvent: e } = g();
  return {
    requestContact: Wt,
    onContactRequested: (n, a) => e("contactRequested", n, a),
    requestWriteAccess: St,
    onWriteAccessRequested: (n, a) => e("writeAccessRequested", n, a)
  };
}
var { initData: Ct, initDataUnsafe: yt, sendData: kt, close: wt } = g();
function Ut(e, o) {
  const t = o.serialize ?? JSON.stringify, n = ref(""), a = (s) => {
    n.value = s, console.error(s);
  }, i = ref(false);
  return {
    error: n,
    isLoading: i,
    execute: () => {
      kt(t(e)), setTimeout(
        () => a(
          "Telegram.WebApp.sendData is only available for custom keyboards."
        ),
        1e3
      );
    },
    executeHttp: async (s, l = {}) => {
      const f = l.closeAfter ?? true;
      i.value = true;
      try {
        const c = await fetch(s, {
          method: "POST",
          body: JSON.stringify({
            initData: Ct,
            initDataUnsafe: yt,
            data: t(e)
          })
        });
        return c.ok || a(`${c.status} ${c.statusText}`), c.ok && f && wt(), c;
      } catch (c) {
        a(String(c));
      } finally {
        i.value = false;
      }
    }
  };
}
var me = ref(Telegram.WebApp.SettingsButton.isVisible);
function ge() {
  me.value = Telegram.WebApp.SettingsButton.isVisible;
}
function U(...e) {
  Telegram.WebApp.SettingsButton.show(...e), ge();
}
function Q(...e) {
  Telegram.WebApp.SettingsButton.hide(...e), ge();
}
function Mt() {
  const { onEvent: e } = g(), o = (t, n) => e("settingsButtonClicked", t, n);
  return {
    isSettingsButtonVisible: computed({
      get() {
        return me.value;
      },
      set(t) {
        t ? U() : Q();
      }
    }),
    onSettingsButtonClicked: o,
    showSettingsButton: U,
    hideSettingsButton: Q
  };
}
function xt(e, o) {
  Telegram.WebApp.shareToStory(e, o);
}
function Qt() {
  return {
    shareToStory: xt
  };
}
var de = ref(Telegram.WebApp.colorScheme);
var be = ref(Telegram.WebApp.themeParams);
var fe = ref(Telegram.WebApp.headerColor);
var Be = ref(Telegram.WebApp.backgroundColor);
function w() {
  de.value = Telegram.WebApp.colorScheme, be.value = {
    ...Telegram.WebApp.themeParams
  }, fe.value = Telegram.WebApp.headerColor, Be.value = Telegram.WebApp.backgroundColor;
}
function H(...e) {
  Telegram.WebApp.setHeaderColor(...e), w();
}
function L(...e) {
  Telegram.WebApp.setBackgroundColor(...e), w();
}
function Ht() {
  const { onEvent: e } = g(), o = (t, n) => e("themeChanged", t, n);
  return o(w), {
    colorScheme: readonly(de),
    themeParams: readonly(be),
    headerColor: computed({
      get() {
        return fe.value;
      },
      set(t) {
        H(t);
      }
    }),
    backgroundColor: computed({
      get() {
        return Be.value;
      },
      set(t) {
        L(t);
      }
    }),
    setHeaderColor: H,
    setBackgroundColor: L,
    onThemeChanged: o
  };
}
var Ae = ref(Telegram.WebApp.isExpanded);
var Te = ref(Telegram.WebApp.viewportHeight);
var he = ref(Telegram.WebApp.viewportStableHeight);
var ve = ref(Telegram.WebApp.isVerticalSwipesEnabled);
function C() {
  Ae.value = Telegram.WebApp.isExpanded, Te.value = Telegram.WebApp.viewportHeight, he.value = Telegram.WebApp.viewportStableHeight, ve.value = Telegram.WebApp.isVerticalSwipesEnabled;
}
function Pt(...e) {
  Telegram.WebApp.expand(...e), C();
}
var z = (...e) => {
  Telegram.WebApp.enableVerticalSwipes(...e), C();
};
var O = (...e) => {
  Telegram.WebApp.disableVerticalSwipes(...e), C();
};
function _t() {
  const { onEvent: e } = g(), o = (t, n) => e("viewportChanged", t, n);
  return o(C), {
    isExpanded: readonly(Ae),
    viewportHeight: readonly(Te),
    viewportStableHeight: readonly(he),
    expand: Pt,
    onViewportChanged: o,
    isVerticalSwipesEnabled: computed({
      get() {
        return ve.value;
      },
      set(t) {
        t ? z() : O();
      }
    }),
    enableVerticalSwipes: z,
    disableVerticalSwipes: O
  };
}
var Lt = {
  install(e) {
    e.component("TgAlert", We), e.component("TgBackButton", Se), e.component("TgBiometricManager", Ce), e.component("TgClosingConfirmation", ye), e.component("TgConfirm", ke), e.component("TgExpandedViewport", we), e.component("TgMainButton", Me), e.component("TgPopup", xe), e.component("TgScanQr", Pe), e.component("TgSettingsButton", _e), e.component("TgShareWidget", Ee), e.component("TgPostWidget", qe), e.component("TgLoginWidget", Re), e.component("TgDiscussionWidget", De);
  }
};
export {
  We as Alert,
  Se as BackButton,
  Ce as BiometricManager,
  ye as ClosingConfirmation,
  ke as Confirm,
  De as DiscussionWidget,
  we as ExpandedViewport,
  Re as LoginWidget,
  Me as MainButton,
  xe as Popup,
  qe as PostWidget,
  Pe as ScanQr,
  _e as SettingsButton,
  Ee as ShareWidget,
  Lt as VueTelegramPlugin,
  g as useWebApp,
  Ne as useWebAppBackButton,
  Ze as useWebAppBiometricManager,
  Rt as useWebAppClipboard,
  tt as useWebAppClosingConfirmation,
  Dt as useWebAppCloudStorage,
  $t as useWebAppHapticFeedback,
  pt as useWebAppMainButton,
  Vt as useWebAppNavigation,
  k as useWebAppPopup,
  vt as useWebAppQrScanner,
  It as useWebAppRequests,
  Ut as useWebAppSendData,
  Mt as useWebAppSettingsButton,
  Qt as useWebAppShare,
  Ht as useWebAppTheme,
  _t as useWebAppViewport
};
//# sourceMappingURL=vue-tg.js.map
